#include <Arduino.h>
#undef F
#include "admm.hpp"
#include "rho_benchmark.hpp"
#include "problem_data/rand_prob_tinympc_params.hpp"  // Generated by your Python script
#include "types.hpp"  // Add this to get NX and NU definitions

void setup() {
    Serial.begin(115200);
    delay(2000);
    
    Serial.println("Starting MPC Benchmark Test");
    Serial.println("Trial,Method,SolveTime,ADMMTime,RhoTime,Iterations,FinalRho");
    
    // Initialize problem & params with debug prints
    Serial.println("\n=== Creating initial objects ===");
    tiny_problem problem;
    tiny_params params;
    
    // Set actual ADMM tolerances (these are what's used in solve_admm)
    params.abs_pri_tol = 1e-2f;
    params.abs_dua_tol = 1e-2f;
    
    // Initialize matrices once
    initialize_benchmark_cache();
    
    // Load matrices from PROGMEM with debug prints
    Serial.println("=== Loading Matrices ===");
    
    // Load Adyn
    for (int i = 0; i < NSTATES*NSTATES; i++) {
        params.cache.Adyn[0](i) = pgm_read_float(&Adyn_data[i]);
    }
    
    // Load Bdyn
    for (int i = 0; i < NSTATES*NINPUTS; i++) {
        params.cache.Bdyn[0](i) = pgm_read_float(&Bdyn_data[i]);
    }
    
    // Load Kinf
    for (int i = 0; i < NINPUTS; i++) {
        for (int j = 0; j < NSTATES; j++) {
            params.cache.Kinf[0](i,j) = pgm_read_float(&Kinf_data[i*NSTATES + j]);
        }
    }
    
    // Debug print after loading
    Serial.println("=== Matrix Loading Complete ===");
    Serial.print("Adyn norm: "); Serial.println(params.cache.Adyn[0].norm());
    Serial.print("Bdyn norm: "); Serial.println(params.cache.Bdyn[0].norm());
    
    // Add this line to compute K and P matrices
    // compute_cache_terms(&params);  // Add this line here!
    // Serial.println("Cache terms computed, exiting for debug...");
    // exit(0);
    
    // Set up rho adapter parameters
    params.rho_adapter.rho_base = 85.0f;
    params.rho_adapter.rho_min = 70.0f;
    params.rho_adapter.rho_max = 100.0f;
    params.rho_adapter.clip = true;
    
    // Load bounds from PROGMEM
    for (int i = 0; i < NINPUTS; i++) {
        params.u_min(i) = pgm_read_float(&umin[i]);
        params.u_max(i) = pgm_read_float(&umax[i]);
    }
    
    for (int i = 0; i < NSTATES; i++) {
        params.x_min(i) = pgm_read_float(&xmin[i]);
        params.x_max(i) = pgm_read_float(&xmax[i]);
    }
    
    // Debug print bounds
    Serial.println("=== Bounds Loaded ===");
    Serial.print("u_min: "); Serial.println(params.u_min.norm());
    Serial.print("u_max: "); Serial.println(params.u_max.norm());
    Serial.print("x_min: "); Serial.println(params.x_min.norm());
    Serial.print("x_max: "); Serial.println(params.x_max.norm());
    
    Serial.println("\n=== Matrix Verification ===");
    
    // Print A matrix (first few elements)
    Serial.println("A matrix (first row):");
    for(int j = 0; j < 4; j++) {
        Serial.print(params.cache.Adyn[0](0,j), 6);
        Serial.print(" ");
    }
    Serial.println();
    
    // Print B matrix
    Serial.println("B matrix (first row):");
    for(int j = 0; j < NINPUTS; j++) {
        Serial.print(params.cache.Bdyn[0](0,j), 6);
        Serial.print(" ");
    }
    Serial.println();
    
    // Print K matrix
    Serial.println("K matrix (first row):");
    for(int j = 0; j < NSTATES; j++) {
        Serial.print(params.cache.Kinf[0](0,j), 6);
        Serial.print(" ");
    }
    Serial.println();
    
    // Print bounds
    Serial.println("Bounds:");
    Serial.print("u_min: "); Serial.println(params.u_min(0));
    Serial.print("u_max: "); Serial.println(params.u_max(0));
    Serial.print("x_min: "); Serial.println(params.x_min(0));
    Serial.print("x_max: "); Serial.println(params.x_max(0));
    
    const int NUM_TRIALS = 5;
    
    // First: Run trials with fixed rho
    params.rho_adapter.analytical_method = false;
    params.cache.rho[0] = params.rho_adapter.rho_base;
    params.cache.rho[1] = params.rho_adapter.rho_base;
    
    for(int i = 0; i < NUM_TRIALS; i++) {
        Serial.println("\n=== Starting Trial " + String(i) + " ===");
        
        // Reset only necessary problem variables instead of full reconstruction
        problem.status = 0;
        problem.iter = 0;
        problem.rho_time = 0;
        problem.solve_time = 0;
        problem.admm_time = 0;
        
        // Set non-zero initial state and inputs
        problem.x.setZero();
        problem.x.col(0) << 1.0f, 2.0f, 3.0f, 4.0f;  // Set initial state
        problem.u.setRandom();  // Random initial inputs
        
        // Set non-zero references
        params.Xref.setRandom();
        params.Uref.setRandom();
        
        // Debug print before solve
        Serial.print("Before solve - pri_tol: ");
        Serial.print(params.abs_pri_tol, 8);
        Serial.print(", dua_tol: ");
        Serial.println(params.abs_dua_tol, 8);
        
        solve_admm(&problem, &params);
        
        Serial.print(i);
        Serial.print(",Fixed,");
        Serial.print(problem.solve_time);
        Serial.print(",");
        Serial.print(problem.admm_time);
        Serial.print(",");
        Serial.print(problem.rho_time);
        Serial.print(",");
        Serial.print(problem.iter);
        Serial.print(",");
        Serial.println(params.cache.rho[problem.cache_level]);
        
        Serial.flush();
        delay(500);
    }
    
    delay(1000);
    
    // Second: Run trials with adaptive rho
    params.rho_adapter.analytical_method = true;
    params.cache.rho[0] = params.rho_adapter.rho_base;
    params.cache.rho[1] = params.rho_adapter.rho_base;
    
    for(int i = 0; i < NUM_TRIALS; i++) {
        Serial.println("\n=== Starting Adaptive Trial " + String(i) + " ===");
        
        // Reset only necessary problem variables
        problem.status = 0;
        problem.iter = 0;
        problem.rho_time = 0;
        problem.solve_time = 0;
        problem.admm_time = 0;
        
        // Set non-zero initial state and inputs
        problem.x.setZero();
        problem.x.col(0) << 1.0f, 2.0f, 3.0f, 4.0f;
        problem.u.setRandom();
        
        // Set non-zero references
        params.Xref.setRandom();
        params.Uref.setRandom();
        
        solve_admm(&problem, &params);
        
        Serial.print(i);
        Serial.print(",Adaptive,");
        Serial.print(problem.solve_time);
        Serial.print(",");
        Serial.print(problem.admm_time);
        Serial.print(",");
        Serial.print(problem.rho_time);
        Serial.print(",");
        Serial.print(problem.iter);
        Serial.print(",");
        Serial.println(params.cache.rho[problem.cache_level]);
        
        Serial.flush();
        delay(500);
    }
    
    Serial.println("Benchmark Complete!");
}

void loop() {
    // Empty
}  