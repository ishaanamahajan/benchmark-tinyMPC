
/*
Auto-generated by CVXPYgen on February 16, 2024 at 16:59:26.
Content: Example program for updating parameters, solving, and inspecting the result.
*/

#include <stdio.h>
#include <stdlib.h>
#include "cpg_workspace.h"
#include "cpg_solve.h"
#include "math.h"
#include "time.h"

static int i;
#define NSTATES 6
#define NINPUTS 3
#define NHORIZON 21
#define NTOTAL 301
#define NRUNS (NTOTAL - NHORIZON - 1)

void add_noise(float x[], float var)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    float noise = ((rand() / RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * var;
  }
}

void print_vector(float xn[], int n)
{
  for (int i = 0; i < n; ++i)
  {
    // Serial.println(xn[i]);
    printf("%f, ", xn[i]);
  }
  printf("\n");
}

void matrix_vector_mult(int n1,
                        int n2,
                        float matrix[],
                        float vector[],
                        float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void matrix_vector_reset_mult(int n1,
                              int n2,
                              float matrix[],
                              float vector[],
                              float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    result_vector[i] = 0.0;
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void system_dynamics(float xn[], float x[], float u[], float A[], float B[], float f[])
{
  matrix_vector_reset_mult(NSTATES, NSTATES, A, x, xn);
  matrix_vector_mult(NSTATES, NINPUTS, B, u, xn);
  for (int i = 0; i < NSTATES; ++i)
  {
    xn[i] += f[i];
  }
}

float compute_norm(float x[], float x_bar[])
{
  float res = 0.0f;
  for (int i = 0; i < NSTATES; ++i)
  {
    res += (x[i] - x_bar[i]) * (x[i] - x_bar[i]);
  }
  return sqrt(res);
}

// May need to save in workspace
const float A[] = {1.0, 0.0, 0.0, 0.05, 0.0, 0.0,
                   0.0, 1.0, 0.0, 0.0, 0.05, 0.0,
                   0.0, 0.0, 1.0, 0.0, 0.0, 0.05,
                   0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                   0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                   0.0, 0.0, 0.0, 0.0, 0.0, 1.0};
const float B[] = {0.000125, 0.0, 0.0,
                   0.0, 0.000125, 0.0,
                   0.0, 0.0, 0.000125,
                   0.005, 0.0, 0.0,
                   0.0, 0.005, 0.0,
                   0.0, 0.0, 0.005};
const float f[] = {0.0, 0.0, -0.0122625, 0.0, 0.0, -0.4905};
const float Q_single = 1e3;
const float xref0[] = {4, 2, 20, -3, 2, -4.5};

float xn[NSTATES] = {0};
float x[NSTATES] = {4.4, 2.2, 22, -3.3, 2.2, -4.95};
float u[NINPUTS] = {0};
float temp = 0;

int main(int argc, char *argv[]){
  // UPDATE SOLVER OPTIONS FIRST

  // for ecos
  // cpg_set_solver_abstol(1e-2);
  // cpg_set_solver_reltol(1e-2);
  // cpg_set_solver_maxit(100);

  // for scs
  // cpg_set_solver_eps_abs(1e-2);
  // cpg_set_solver_eps_rel(1e-2);
  // cpg_set_solver_max_iters(100);

  srand(1);
  for (int k = 0; k < NRUNS; ++k) {
    //// Update current measurement
    for (int i = 0; i < NSTATES; ++i)
    {
      cpg_update_param1(i, x[i]);
    }
    printf("x = ");
    print_vector(x, NSTATES);

    // for (int i = 0; i < NHORIZON; ++i)
    // {
    //   printf(" cpg_params_vec[0] = %f\n", cpg_params_vec[i]);
    // }

    //// Update references
    for (int i = 0; i < NHORIZON; ++i)
    {
      for (int j = 0; j < NSTATES; ++j)
      {
        temp = xref0[j] + (0-xref0[j]) * (k+i) / (NTOTAL-1);
        // printf("temp = %f\n", temp);
        cpg_update_param3(i*(NSTATES+NINPUTS) + j, -Q_single * temp);
      }
    }
    // for (int i = 0; i < NHORIZON; ++i)
    // {
    //   printf("  cpg_params_vec[0] = %f\n", cpg_params_vec[i]);
    // }
    
    // Solve the problem instance
    clock_t start = clock();
    // printf("%d\n", start);
    cpg_solve();
    clock_t end = clock();
    // printf("%d\n", end-start);
    float cpu_time_used = ((float) (end - start)) / CLOCKS_PER_SEC; 
    printf("cpu_time_used = %f\n", cpu_time_used);

    // Get data from the result
    for (i=NSTATES; i<NSTATES+NHORIZON; i++) {
      u[i-NSTATES] = CPG_Result.prim->var2[i];
    }
    printf("u = ");
    print_vector(u, NINPUTS);

    // Simulate the system
    system_dynamics(xn, x, u, A, B, f);
    printf("xn = ");
    print_vector(xn, NSTATES);

    // Update the state
    memcpy(x, xn, NSTATES * (sizeof(float)));
    // print_vector(x, NSTATES);
    add_noise(x, 0.01);
    // print_vector(x, NSTATES);

    // Print objective function value
    // printf("obj = %f\n", CPG_Result.info->obj_val);
  }
  return 0;
}

// Make it float for SCS: (NOT WORKING)
// make SFLOAT=1












/*
Auto-generated by CVXPYgen on February 16, 2024 at 16:59:26.
Content: Example program for updating parameters, solving, and inspecting the result.
*/

#include "Arduino.h"

#include <stdio.h>
#include <stdlib.h>
#include "cpp_compat.h"
#include "math.h"

#include "cpg_workspace.h"
#include "cpg_solve.h"
#include "cpg_problem.h"


#define NRUNS (NTOTAL - NHORIZON - 1)

static int i;

void add_noise(float x[], float var)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    float noise = ((rand() / RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * var;
  }
}

void print_vector(float xn[], int n)
{
  for (int i = 0; i < n; ++i)
  {
    // Serial.println(xn[i]);
    printf("%f, ", xn[i]);
  }
  printf("\n");
}

void matrix_vector_mult(int n1,
                        int n2,
                        float matrix[],
                        float vector[],
                        float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void matrix_vector_reset_mult(int n1,
                              int n2,
                              float matrix[],
                              float vector[],
                              float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    result_vector[i] = 0.0;
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void system_dynamics(float xn[], float x[], float u[], float A[], float B[], float f[])
{
  matrix_vector_reset_mult(NSTATES, NSTATES, A, x, xn);
  matrix_vector_mult(NSTATES, NINPUTS, B, u, xn);
  for (int i = 0; i < NSTATES; ++i)
  {
    xn[i] += f[i];
  }
}

float compute_norm(float x[], float x_bar[])
{
  float res = 0.0f;
  for (int i = 0; i < NSTATES; ++i)
  {
    res += (x[i] - x_bar[i]) * (x[i] - x_bar[i]);
  }
  return sqrt(res);
}

const float xref0[] = {4, 2, 20, -3, 2, -4.5};

float xn[NSTATES] = {0};
float x[NSTATES] = {4.4, 2.2, 22, -3.3, 2.2, -4.95};
float u[NINPUTS] = {0};
float temp = 0;

float u_test[NINPUTS] = {0};
float x_test[NSTATES] = {0};
float x1_test[NSTATES] = {0};

float max_dyn_vio = 0.0;
float max_cone_vio = 0.0;
float max_bnd_vio = 0.0;

int main(int argc, char *argv[]){
  // delay for 4 seconds
  for (int i = 0; i < 4; ++i)
  {
    delay(1000);
  }
  printf("Start SCS Rocket Landing\n");

  // UPDATE SOLVER OPTIONS FIRST

  // for scs
  cpg_set_solver_eps_abs(1e-2);
  cpg_set_solver_eps_rel(1e-2);
  cpg_set_solver_max_iters(1);
  
  srand(1);
  for (int k = 0; k < 1; ++k) {
    //// Update current measurement
    for (int i = 0; i < NSTATES; ++i)
    {
      cpg_update_param1(i, x[i]);
    }
    printf("x = ");
    print_vector(x, NSTATES);

    //// Update references
    for (int i = 0; i < NHORIZON; ++i)
    {
      for (int j = 0; j < NSTATES; ++j)
      {
        temp = xref0[j] + (0-xref0[j]) * (k+i) / (NTOTAL-1);
        // printf("%f, ", temp);
        cpg_update_param3(i*(NSTATES+NINPUTS) + j, -Q_single * temp);
      }
    }
    
    // Solve the problem instance
    unsigned long start = micros();
    // printf("%d\n", start);
    cpg_solve();
    unsigned long end = micros();
    // printf("%d\n", end-start);
    printf("STEP: %3d TIME: %10d\n", k, end - start);

    // for (i=0; i<10; i++) {
    //   printf("%f ", CPG_Result.prim->var2[i]);
    // }
    // Get data from the result
    for (i=0; i<NINPUTS; i++) {
      u[i] = CPG_Result.prim->var2[i+NSTATES];
    }
    printf("u = ");
    print_vector(u, NINPUTS);

    // Simulate the system
    system_dynamics(xn, x, u, A, B, f);
    // printf("xn = ");
    print_vector(xn, NSTATES);

    // Update the state
    memcpy(x, xn, NSTATES * (sizeof(float)));
    // print_vector(x, NSTATES);
    add_noise(x, 0.01);
    // print_vector(x, NSTATES);

    // Print objective function value
    // printf("obj = %f\n", CPG_Result.info->obj_val);
  }
  return 0;
}
