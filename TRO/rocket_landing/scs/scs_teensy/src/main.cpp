
/*
Auto-generated by CVXPYgen on February 16, 2024 at 16:59:26.
Content: Example program for updating parameters, solving, and inspecting the result.
*/
#include "Arduino.h"
#include "cpp_compat.h"
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdint.h>

// Forward declaration for freeRam helper
static uint32_t freeRam();

// System call stubs for Teensy
extern "C" {
  int _open(const char *name, int flags, int mode) { return -1; }
  int _close(int fd) { return -1; }
  int _read(int fd, void *buf, size_t count) { return -1; }
  int _write(int fd, const void *buf, size_t count) { return -1; }
  int _lseek(int fd, int offset, int whence) { return -1; }
  int _fstat(int fd, void *st) { return -1; }
  int _isatty(int fd) { return 0; }
}

extern "C" {
#include "cpg_workspace.h"
#include "cpg_solve.h"
#include "cpg_problem.h"
}

static int i;

void add_noise(float x[], float var)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    float noise = ((rand() / (double)RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * var;
  }
}

void print_vector(float xn[], int n)
{
  for (int i = 0; i < n; ++i)
  {
    Serial.print(xn[i]);
    Serial.print(", ");
  }
  Serial.println();
}

void matrix_vector_mult(int n1,
                        int n2,
                        const float matrix[],
                        const float vector[],
                        float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void matrix_vector_reset_mult(int n1,
                              int n2,
                              const float matrix[],
                              const float vector[],
                              float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    result_vector[i] = 0.0;
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void system_dynamics(float xn[], const float x[], const float u[], const float A[], const float B[], const float f[])
{
  matrix_vector_reset_mult(NSTATES, NSTATES, A, x, xn);
  matrix_vector_mult(NSTATES, NINPUTS, B, u, xn);
  for (int i = 0; i < NSTATES; ++i)
  {
    xn[i] += f[i];
  }
}

float compute_norm(const float x[], const float x_bar[])
{
  float res = 0.0f;
  for (int i = 0; i < NSTATES; ++i)
  {
    res += (x[i] - x_bar[i]) * (x[i] - x_bar[i]);
  }
  return sqrt(res);
}

const float xref0[] = {4, 2, 20, -3, 2, -4.5};

float xn[NSTATES] = {0};
float x[NSTATES] = {4.4, 2.2, 22, -3.3, 2.2, -4.95};
float u[NINPUTS] = {0};
float temp = 0;
// Variables to record free RAM around solver allocations
static uint32_t free_ram_before = 0;
static uint32_t free_ram_after = 0;

int main(){
  Serial.begin(9600);
  delay(1000);
  Serial.print("Horizon: ");
  Serial.println(NHORIZON);
  delay(500);
  
  // for scs
  cpg_set_solver_eps_abs(1e-2);
  cpg_set_solver_eps_rel(1e-3);
  cpg_set_solver_max_iters(500);

  srand(1);
  for (int k = 0; k < NTOTAL; ++k) {
    // Record free RAM just before the very first solve
    if (k == 0) {
      free_ram_before = freeRam();
      Serial.print("# Free RAM before first solve: ");
      Serial.println(free_ram_before);
    }
    //// Update current measurement
    for (int i = 0; i < NSTATES; ++i)
    {
      cpg_update_param1(i, x[i]);
    }

    //// Update references
    for (int i = 0; i < NHORIZON; ++i)
    {
      for (int j = 0; j < NSTATES; ++j)
      {
        if (k+i >= NTOTAL)
        {
          temp = 0.0;
        }
        else
        {
          temp = xref0[j] + (0-xref0[j]) * (float)(k+i) / (NTOTAL);
        }
        cpg_update_param3(i*(NSTATES+NINPUTS) + j, -Q_single * temp);
      }
    }
    
    // Solve the problem instance
    unsigned long start = micros();
    cpg_solve();
    unsigned long end = micros();
    Serial.print(CPG_Info.iter); 
    Serial.print(" "); 
    Serial.println((int)(end - start));

    // Get data from the result
    for (i=0; i<NINPUTS; i++) {
      u[i] = CPG_Result.prim->var2[i+NSTATES];
    }

    // Simulate the system
    system_dynamics(xn, x, u, A, B, f);

    // Update the state
    memcpy(x, xn, NSTATES * (sizeof(float)));
    add_noise(x, 0.01);
  }

  // Record free RAM after all solves are finished
  free_ram_after = freeRam();
  Serial.print("# Free RAM after last solve: ");
  Serial.println(free_ram_after);
  Serial.print("# Heap allocated by solver: ");
  Serial.println(free_ram_before - free_ram_after);
  
  Serial.println("# Benchmark completed");
  return 0;
}

// Return an estimate of free RAM by measuring gap between heap and stack
static uint32_t freeRam() {
  uint32_t stack_top;
  stack_top = (uint32_t)&stack_top;    // current stack pointer
  void *heap_ptr = malloc(4);          // current heap end after small alloc
  uint32_t heap_top = (uint32_t)heap_ptr;
  free(heap_ptr);
  return stack_top - heap_top;         // remaining free RAM
}
