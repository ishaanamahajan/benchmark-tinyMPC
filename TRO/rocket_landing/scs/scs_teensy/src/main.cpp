/*
Auto-generated by CVXPYgen on February 16, 2024 at 16:59:26.
Content: Memory-safe allocation testing to prevent crashes.
*/
#include "Arduino.h"
#include "cpp_compat.h"
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <stdint.h>

// Forward declaration for freeRam helper
static uint32_t freeRam();
static bool testMemoryAllocation(size_t bytes);

// System call stubs for Teensy
extern "C" {
  int _open(const char *name, int flags, int mode) { return -1; }
  int _close(int fd) { return -1; }
  int _read(int fd, void *buf, size_t count) { return -1; }
  int _write(int fd, const void *buf, size_t count) { return -1; }
  int _lseek(int fd, int offset, int whence) { return -1; }
  int _fstat(int fd, void *st) { return -1; }
  int _isatty(int fd) { return 0; }
}

extern "C" {
#include "cpg_workspace.h"
#include "cpg_solve.h"
#include "cpg_problem.h"
}

static int i;

void add_noise(float x[], float var)
{
  for (int i = 0; i < NSTATES; ++i)
  {
    float noise = ((rand() / (double)RAND_MAX) - 0.5) * 2; // random -1 to 1
    x[i] += noise * var;
  }
}

void print_vector(float xn[], int n)
{
  for (int i = 0; i < n; ++i)
  {
    Serial.print(xn[i]);
    Serial.print(", ");
  }
  Serial.println();
}

void matrix_vector_mult(int n1,
                        int n2,
                        const float matrix[],
                        const float vector[],
                        float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void matrix_vector_reset_mult(int n1,
                              int n2,
                              const float matrix[],
                              const float vector[],
                              float result_vector[])
{
  // n1 is rows of matrix
  // n2 is cols of matrix, or vector
  int i, j; // i = row; j = column;
  for (i = 0; i < n1; i++)
  {
    result_vector[i] = 0.0;
    for (j = 0; j < n2; j++)
    {
      result_vector[i] += matrix[i * n2 + j] * vector[j];
    }
  }
}

void system_dynamics(float xn[], const float x[], const float u[], const float A[], const float B[], const float f[])
{
  matrix_vector_reset_mult(NSTATES, NSTATES, A, x, xn);
  matrix_vector_mult(NSTATES, NINPUTS, B, u, xn);
  for (int i = 0; i < NSTATES; ++i)
  {
    xn[i] += f[i];
  }
}

float compute_norm(const float x[], const float x_bar[])
{
  float res = 0.0f;
  for (int i = 0; i < NSTATES; ++i)
  {
    res += (x[i] - x_bar[i]) * (x[i] - x_bar[i]);
  }
  return sqrt(res);
}

const float xref0[] = {4, 2, 20, -3, 2, -4.5};

float xn[NSTATES] = {0};
float x[NSTATES] = {4.4, 2.2, 22, -3.3, 2.2, -4.95};
float u[NINPUTS] = {0};
float temp = 0;

// Memory tracking variables
static uint32_t baseline_ram = 0;
static uint32_t post_config_ram = 0;
static uint32_t post_solve_ram = 0;
static bool solver_initialized = false;

// Test if we can allocate a given amount of memory
static bool testMemoryAllocation(size_t bytes) {
  void* test_ptr = malloc(bytes);
  if (test_ptr != NULL) {
    free(test_ptr);
    return true;
  }
  return false;
}

// Find maximum allocatable block
static size_t findMaxAllocation() {
  size_t max_size = 0;
  size_t test_size = 1024 * 1024; // Start with 1MB
  
  // Binary search for largest allocatable block
  size_t min_size = 0;
  size_t max_test = test_size;
  
  while (min_size < max_test - 1) {
    size_t mid = (min_size + max_test) / 2;
    if (testMemoryAllocation(mid)) {
      min_size = mid;
      max_size = mid;
    } else {
      max_test = mid;
    }
  }
  
  return max_size;
}

int main(){
  Serial.begin(9600);
  delay(1000);
  
  Serial.println("# ========================================");
  Serial.println("# Memory-Safe MPC Allocation Test");
  Serial.println("# ========================================");
  
  Serial.print("# Horizon: ");
  Serial.println(NHORIZON);
  Serial.print("# States: ");
  Serial.println(NSTATES);
  Serial.print("# Inputs: ");
  Serial.println(NINPUTS);
  Serial.print("# Total iterations planned: ");
  Serial.println(NTOTAL);
  
  // Get baseline memory info
  baseline_ram = freeRam();
  size_t max_allocation = findMaxAllocation();
  
  Serial.print("# Baseline free RAM: ");
  Serial.println(baseline_ram);
  Serial.print("# Maximum allocatable block: ");
  Serial.print(max_allocation);
  Serial.print(" bytes (");
  Serial.print(max_allocation / 1024.0, 2);
  Serial.println(" KB)");
  
  // Estimate solver memory requirements (rough calculation)
  size_t estimated_solver_memory = 0;
  // For QP solver: roughly O(n^2 + m*n) where n=states*horizon, m=constraints
  size_t qp_vars = NSTATES * NHORIZON + NINPUTS * NHORIZON;
  estimated_solver_memory = qp_vars * qp_vars * sizeof(float); // Hessian matrix
  estimated_solver_memory += qp_vars * 100 * sizeof(float); // Constraint matrices (rough estimate)
  estimated_solver_memory += qp_vars * 10 * sizeof(float); // Working arrays
  
  Serial.print("# Estimated solver memory need: ");
  Serial.print(estimated_solver_memory);
  Serial.print(" bytes (");
  Serial.print(estimated_solver_memory / 1024.0, 2);
  Serial.println(" KB)");
  
  if (estimated_solver_memory > max_allocation) {
    Serial.println("# ⚠ WARNING: Estimated memory exceeds available!");
    Serial.println("# ⚠ Solver initialization may fail or crash!");
    Serial.println("# ⚠ Consider reducing horizon or problem size.");
    Serial.println("# ⚠ Attempting initialization anyway...");
  } else {
    Serial.println("# ✓ Estimated memory within available limits");
  }
  
  delay(2000); // Give time to read warnings
  
  Serial.println("# ========================================");
  Serial.println("# Attempting solver configuration...");
  
  // Configure solver with watchdog
  Serial.println("# Step 1: Setting solver parameters...");
  cpg_set_solver_eps_abs(1e-2);
  
  post_config_ram = freeRam();
  Serial.print("# RAM after parameter setup: ");
  Serial.println(post_config_ram);
  
  cpg_set_solver_eps_rel(1e-3);
  cpg_set_solver_max_iters(500);
  
  Serial.println("# Step 2: Configuration complete, checking memory...");
  uint32_t after_config = freeRam();
  Serial.print("# RAM after full config: ");
  Serial.println(after_config);
  
  if (baseline_ram > after_config) {
    uint32_t config_alloc = baseline_ram - after_config;
    Serial.print("# Configuration allocated: ");
    Serial.print(config_alloc);
    Serial.print(" bytes (");
    Serial.print(config_alloc / 1024.0, 2);
    Serial.println(" KB)");
  }
  
  Serial.println("# ========================================");
  Serial.println("# Attempting first solve (DANGER ZONE)...");
  
  srand(1);
  
  // Set up first iteration parameters
  for (int i = 0; i < NSTATES; ++i) {
    cpg_update_param1(i, x[i]);
  }
  
  for (int i = 0; i < NHORIZON; ++i) {
    for (int j = 0; j < NSTATES; ++j) {
      temp = xref0[j];
      cpg_update_param3(i*(NSTATES+NINPUTS) + j, -Q_single * temp);
    }
  }
  
  Serial.println("# Parameters updated, attempting solve...");
  Serial.println("# If this hangs/crashes, problem is too big for available memory");
  
  // The critical moment - this is where it will crash if memory insufficient
  unsigned long start = micros();
  cpg_solve();
  unsigned long end = micros();
  
  // If we get here, success!
  Serial.println("# ✓ SUCCESS: First solve completed!");
  
  post_solve_ram = freeRam();
  Serial.print("# RAM after first solve: ");
  Serial.println(post_solve_ram);
  
  if (baseline_ram > post_solve_ram) {
    uint32_t total_alloc = baseline_ram - post_solve_ram;
    Serial.print("# TOTAL SOLVER ALLOCATION: ");
    Serial.print(total_alloc);
    Serial.print(" bytes (");
    Serial.print(total_alloc / 1024.0, 2);
    Serial.println(" KB)");
  }
  
  Serial.print("# First solve time: ");
  Serial.print((int)(end - start));
  Serial.println(" microseconds");
  
  Serial.print("# Solver iterations: ");
  Serial.println(CPG_Info.iter);
  
  solver_initialized = true;
  
  Serial.println("# ========================================");
  Serial.println("# Running abbreviated benchmark...");
  
  // Run just a few more iterations to verify stability
  int test_iterations = min(10, NTOTAL);
  
  for (int k = 1; k < test_iterations; ++k) {
    // Update parameters
    for (int i = 0; i < NSTATES; ++i) {
      cpg_update_param1(i, x[i]);
    }
    
    for (int i = 0; i < NHORIZON; ++i) {
      for (int j = 0; j < NSTATES; ++j) {
        if (k+i >= NTOTAL) {
          temp = 0.0;
        } else {
          temp = xref0[j] + (0-xref0[j]) * (float)(k+i) / (NTOTAL);
        }
        cpg_update_param3(i*(NSTATES+NINPUTS) + j, -Q_single * temp);
      }
    }
    
    start = micros();
    cpg_solve();
    end = micros();
    
    Serial.print(k);
    Serial.print(" ");
    Serial.print(CPG_Info.iter);
    Serial.print(" ");
    Serial.println((int)(end - start));
    
    // Get control and simulate
    for (i = 0; i < NINPUTS; i++) {
      u[i] = CPG_Result.prim->var2[i + NSTATES];
    }
    
    system_dynamics(xn, x, u, A, B, f);
    memcpy(x, xn, NSTATES * sizeof(float));
    add_noise(x, 0.01);
  }
  
  Serial.println("# ========================================");
  Serial.println("# MEMORY ALLOCATION RESULTS");
  Serial.println("# ========================================");
  
  if (solver_initialized && baseline_ram > post_solve_ram) {
    uint32_t total_allocation = baseline_ram - post_solve_ram;
    Serial.print("# SUCCESS: Solver requires ");
    Serial.print(total_allocation);
    Serial.print(" bytes (");
    Serial.print(total_allocation / 1024.0, 2);
    Serial.println(" KB) of RAM");
    
    Serial.print("# Memory efficiency: ");
    Serial.print((total_allocation * 100.0) / max_allocation, 1);
    Serial.println("% of available memory used");
    
    if (total_allocation < max_allocation / 2) {
      Serial.println("# ✓ GOOD: Plenty of memory headroom remaining");
    } else if (total_allocation < max_allocation * 0.8) {
      Serial.println("# ⚠ CAUTION: High memory usage but workable");
    } else {
      Serial.println("# ⚠ WARNING: Very high memory usage, near limits");
    }
  }
  
  Serial.println("# Test completed successfully!");
  return 0;
}

// Return an estimate of free RAM by measuring gap between heap and stack
static uint32_t freeRam() {
  uint32_t stack_top;
  stack_top = (uint32_t)&stack_top;
  void *heap_ptr = malloc(4);
  uint32_t heap_top = (uint32_t)heap_ptr;
  free(heap_ptr);
  return stack_top - heap_top;
}